---
title:  "What is poetic about computation?"
summary: "Chapter One introduces the poetic aspects of computation and considers how engaging technology with this lens can lead to new political possibilities. In connecting modern computation to its historical antecedents, it problematizes the fetishistic embrace of technology and presents a case for radical intervention."
pdf: "/pdfs/chapterOne.pdf"
chapter: 1
page: 1
active: true
references:
  - title: 'Gramophone, film, typewriter'
    link: 'https://monoskop.org/images/7/73/Kittler_Friedrich_Gramophone_Film_Typewriter.pdf'
    author: 'Friedrich Kittler'
    body: 'Gramophone, film, typewriter by Friedrich Kittler'
  - title: 'War in the Age of Intelligent Machines'
    link: 'https://monoskop.org/images/c/c0/DeLanda_Manuel_War_in_the_Age_of_Intelligent_Machines.pdf'
    author: 'Manuel DeLanda'
    body: 'War in the Age of Intelligent Machines by Manuel DeLanda'
  - title: 'Work in the age of Mechanical Reproduction'
    link: 'https://www.marxists.org/reference/subject/philosophy/works/ge/benjamin.htm'
    author: 'Walter Bejamin'
    body: 'Work in the age of Mechanical Reproduction by Walter Benjamin'
  - title: 'Being is a computational mode'
    link: 'http://cultureandcommunication.org/galloway/being-is-a-computational-mode'
    author: 'Alex Galloway'
    body: 'Being is a computational mode by Alex Galloway'
  - title: 'Claude Shannon: Reluctant Father of the Digital Age'
    link: 'https://www.technologyreview.com/s/401112/claude-shannon-reluctant-father-of-the-digital-age/'
    author: 'M. Mitchell Waldrop'
    body: 'Claude Shannon: Reluctant Father of the Digital Age by M. Mitchell Waldrop'
sections:
  - title: "Introduction"
    paragraphs:
      - text: "Greetings. Welcome to the first class of Poetics and Politics of Computation at the School for Poetic Computation(SFPC). I’d like to begin the class by asking “What is poetic computation?” First, there is the <span class='italic'>poetics of code</span>, which refers to code as a form of poetry. There is something poetic about code itself, the way that syntax works, the way that repetitions work, and the way that instruction becomes execution through abstraction. There is also what I call the <span class='italic'>poetic effect of code</span>, which is an aesthetic experience realized through code. In other words, when the mechanics of words are in the right place, the language transcends its constraints and rules, and in turn, creates this <span class='italic'>poetic effect</span> whereby thought is transformed into experience."
      - text: "Together, the italic <span class='italic'>poetics of code</span> and the <span class='italic'>poetic effect of code</span> form ‘poetic computation.’ The terms code and computation are often used interchangeably, but I should note that code is only one aspect of computation. Code is a series of instruction for computation that requires logical systems and often times hardware to make the instructions computable. In that sense, computation is a higher level concept than code. For our purposes, however, we can use <span class='italic'>poetics of code</span> and <span class='italic'>poetics of computation</span> interchangeably throughout these discussions."
      - text: "To a non-coder, non-artist friend, or to those just beginning to learn to program, I often say code may look like poetry in an alien language. And to those more experienced with code, writing code sometimes feels like writing poetry because it doesn’t always ‘work.’ I mean two things by ‘work’: first, does it work as an art form? Is it good poetry? On the other hand, I mean ‘work’ in a more utilitarian sense. Does it have practical application?"  
        inlineImage:
          - src: "chapter-1/image5.jpg"
            caption: '<a href="http://taeyoonchoi.com/projects/errantic-poetry/">Errantic Poetry</a>, Taeyoon Choi, 2016'
      - text: "At SFPC, we like to say that poetic computation is when language meets mathematics, and logic meets electricity. Sometimes, poetic computation is literally writing poems with code. At SFPC, some of our teachers and students write poetry with algorithms to explore what the language can do. When we started the school, a lot of people asked if the school is for generative poetry or electronic literature. We clarified that while we are definitely interested in the intersection of language and computation, we want to explore a broader definition of the ‘poetic.’ We want to investigate the art of computation as well as the expressive qualities of code, including its aesthetic, visual, aural and material aspects."
      - text: While this artistic potential lies at the core of the school’s excitement about code and computation, I’m interested in how this turn towards art may help us explore political possibilities. In this class, I consider computation to be a lens for examining reality and thinking about emergent issues in the world. In other words, computation can be a vehicle for imagining new ways of being in the world. Let’s first step back to look at material precedents of modern computation and computers.
  - title: Genealogy of computers
    paragraphs: 
      - text: The first computers were human.<span class="citation-num">1</span> Long before electronic computers were invented, ‘computing’ was a profession for people who calculated and managed data. The (human) computers worked with mathematicians to execute algorithms and theories. Mathematicians would ask the (human) computers to work on the numbers.<span class="citation-num">2</span> Often times, there would be multiple (human) computers working on the same algorithms in order to detect and prevent mistakes. Considering the history, it’s curious that we’ve created such a dichotomy between computers and humans these days. In a sense we are all computers (people who compute). Computers need not always be metallic, electronic or very distinct from us. Computer scientists, among others, may be wary of my broad definition of computers, but I like to think computers are whenever a logical way of thinking is applied to a given problem. 
        citations:
          - text: "<span class='citation-num'>1</span>Charles Petzold, Code: The Hidden Language of Computer Hardware and Software (Redmond: Microsoft Press, 1999).  <a href='http://www.charlespetzold.com/code/index.html'>http://www.charlespetzold.com/code/index.html</a>"
            author: "This is the person who this is by"
            preview: "Sample Citation One"
          - text: "<span class='citation-num'>2</span>David Alan Grier, When Computers Were Human (Princeton: Princeton University Press: 2005)."
        image: 
          - src: "chapter-1/image3.jpg"
            caption: "Programmers of ENIAC, 1946: Via @ <a href='http://www.phillyvoice.com/70-years-ago-six-philly-women-eniac-digital-computer-programmers/'>Philly Voice</a>"
      - text: We can trace the evolution of contemporary computers from operations research around World War II to management science in the second half of the 20th century. Operations research mainly focused on calculations for ballistic missiles and planning logistics for moving large numbers of troops at the same time, while management science, which grew out of operations research, included anything from accounting to quantitative research. Actually, much of the software we use today, such as Microsoft Excel and Word, Gmail and Facebook, share a distant lineage to both.

      - text: Operations research and management science are related because they both were influenced by the discipline of cybernetics, the theory of self-regulating systems comprised of feedback loops. When these self-regulating systems were accompanied by powerful computers, it made possible the centralization and decentralization of information and material goods on a vast scale. The tension between these two states marked temporary crises and resolutions in Capitalism, manifest as production and dispersion, times of abundance and scarcity, or even war and peace. In this way, war machines and international finance share the same ancestors. As we move on, it’s important to keep in mind that I’m presenting an incomplete genealogy of computers, and I encourage you to go back after the talk and explore the specifics.  

      - subTitle: Mechanical computer
        text: In the early 19th century, Charles Babbage, an English mathematician and engineer, invented arguably the first mechanical computer. This tabulating machine, designed to calculate large sets of data, was built with the materials and technology available to Babbage at the time. It was an era of ships, railroads, and lots of mechanical inventions, so he constructed his computer as a system of moving gears. Very mechanical! 
      - text: It’s interesting to think in general about how people’s ideas for inventions were constrained by the materials available to them. In fact, the history of computers is closely related to discovery of new materials. It is thus remarkable that Babbage managed to imbue his mechanical computer with the conceptual framework of the not-yet-possible computers. The <a href="https://en.wikipedia.org/wiki/Analytical_Engine" target="_blank">Analytical Engine</a>, one of the incomplete prototypes by Babbage, became a platform for Ada Lovelace, a mathematician, to collaborate and create algorithms. In this way, Lovelace came to be considered one of the first ‘computer programmers,’ a person who instructs machines in automated tasks.<span class="citation-num">3</span>
        citations:
          - text: "<span class='citation-num'>3</span>Charles Petzold, Code: The Hidden Language of Computer Hardware and Software."
      - subTitle: Analog Computer
      
      - text: The analog computer was a stepping stone to the digital computer because while it still had mechanical components, it also had analog components that used a continuous (electrical) signal. <span class="citation-num">4</span> Vannevar Bush, a mathematician and electrical engineer, who we’ll discuss more next week, did critical work on the analog computer. Its components included disc and wheel mechanisms that could calculate, for example, the trajectory of a missile. Computers at this time, however, were still slow, prone to failure and in need of endless fiddling by engineers. 
        citations:
          - text: "<span class='citation-num'>4</span>As we’ll see, this is different from digital computers which operate with discrete (electronic) signals with decision-making capacity." 
      - subTitle: Electronic
        text: The next major leap was in 1937 when Claude Shannon, a very bright student of Bush’s, wrote a master’s thesis at MIT called “<a href="https://en.wikipedia.org/wiki/A_Symbolic_Analysis_of_Relay_and_Switching_Circuits" target="_blank">A Symbolic Analysis of Relay and Switching Circuits</a>.<span class="citation-num">5</span> It showed that electronic relays could be used to carry out binary logic operations. Until this point, there was the concept of binary logic but not reliable electrical materials to execute it. Shannon discovered that relays could switch on and off, thereby changing the direction of electrical flow and allowing for new logical operations. This is very similar to how transistors work, which were invented about ten years later at the Bell Telephone Labs in New Jersey. <span class="citation-num">6</span>
        citations: 
          - text: " <span class='citation-num'>5</span> Claude Elwood Shannon, “A Symbolic Analysis of Relay and Switching Circuits.” (Cambridge: Massachusetts Institute of Technology, 1940), <a href='http://dspace.mit.edu/handle/1721.1/11173' target='_blank'>http://hdl.handle.net/1721.1/11173</a>."
          - text: "<span class='citation-num'>6</span>Priya Ganapati, “Dec. 23, 1947: Transistor Opens Door to Digital Future,” Wired, December 23, 2009, <a href='https://www.wired.com/2009/12/1223shockley-bardeen-brattain-transistor/' target='_blank'>https://www.wired.com/2009/12/1223shockley-bardeen-brattain-transistor/</a>."
      - text: We can think of the transistor as the smallest conceptual building block in a computer. Transistors have three legs, or terminals, called the collector, base and emitter. The signal comes in through the base, pulls current into the collector, which gets amplified through the emitter. This is one of the essential features of the transistor, that it can amplify a signal. If the signal is really small or noisy, it can still get a clean output from the transistor. This makes long distance communication possible because while we can easily talk to each other in this room, we’d need to amplify the signal to communicate over a larger distance.
      - text: The other essential feature of the transistor is its ability to switch on and off, thereby enabling binary logic. Recall that Shannon’s relays, which directly preceded the transistor, also made binary logic possible. While an electrical current can only travel in one direction, transistors, by switching on or off, can change the direction of the current. Zeroes and ones in computers, by the way, are simply these changes in the electrical current. These simple characteristics of transistors made it possible to build electrical circuits that could compute exceedingly complex logic.
      - text: Last year I exhibited the process of making a handmade computer as an artwork. This is a 64 Bit RAM and 10 step counter, so it is cycling through ten states and you can encode four bits of information and recall them. It’s the first computer I built that I can say is my design because before then I was just copying the history of computer design. Handmade computers is how I approach computation. What makes a computer so powerful is that it doesn’t mind repeating the small tasks, whereas we humans get bored and tired so easily. Working on the Handmade Computer project, I had to endure repetitive soldering and wiring. In a sense, the laborious process was a search for the poetics of computation. 
      - text: Again, what is the <span class="italic">poetics of computation</span>? The origin of the word <span class="italic">poetics</span> is Poïesis, which means to create and give form. What is the form of computer? What factors were in place to give this particular form to it? Perhaps by making a computer by hand, we can think about the <span class="italic">poetic effect of computation</span>. How can computers create the varying senses of time coexisting in a space? Can we consider code as language rather than technology? After all, computation is not merely a technological subject, but a kind of medium and spirit that runs contemporary society. I will explore the concepts of poetic computation throughout the lectures, and especially in Lecture 5 on Translation. For now, I’d like to steer our conversation toward the question of the politics of code.   

---
